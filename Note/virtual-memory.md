## 연속 메모리 할당
- 프로세스에 연속적인 메모리 공간을 할당
- 비효율적인 방식
- 외부 단편화랑 문제가 생기기 때문

## 스와핑
- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫒아내고 그렇게 생긴 빈 공간에 새 프로세스 적재
- 사용되지 않는 프로세스들을 쫓아내는 과정을 스왑 아웃이라고 한다
- 스왑 영역에 있는 프로세스가 다시 메모리도 적재되는 것을 스왑 인 이라고 한다
- 프로세스들이 요구하는 메모리 공간 크기가 실제 메모리 크기 보다 크더라도 스와핑을 통해 적재가 가능하다

## 메모리 할당
- 프로세스는 메모리의 빈 공간에 할당되어야 한다

### 최소 적합
- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
- 검색 최소화, 빠른 할당

### 최적 적합
- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당(크기가 얼추 딱맞는 공간)

### 최악 적합
- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당

## 외부 단편화
- 프로세스들이 실행되고 종료되길 반복하면서 메모리 사이사이에 빈 공간 발생
- 이러한 공간들이 프로세스를 할당하기 어려울 만큼 작은 메모리 공간이면 프로세스는 할당되지 못하고 메모리는 메모리대로 낭비 하게된다.

## 외부 단편화 해결 
### 메모리 압축
- 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
- 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 빈 공간으로 반드는 방법
### 가상 메모리 기법(페이징) 
#### 가상 메모리
- 실행하고자 하는 프록램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행 할 수 있게 하는 기술
- 페이징, 세그멘테이션
#### 페이징이란?
1. 프로세스의 논리 주소 공간을 페이지 라는 일정 단위로 자르고
2. 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 일정한 단위로 자른 뒤
3. 페이지를 프레임에 할당하는 가상 메모리 관리 기법

#### 페이징에서의 스와핑
- 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
- 메모리에 적재될 필요가 없응 페이지들은 보조기억장치로 스왑 아웃
- 실행에 핑요한 페이지들은 메모리로 스왑 인
- 페이징에서의 스와핑이 가능하다는건 하나의 프로세스의 모든 페이지가 반드시 메모리에 모두 적재될 필요는 없다라는 것을 시사한다
- 물리 메모리보다 큰 프로세스도 실행가능하게 만들어준다

- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기 어렵다 (메모리에 불연속적으로 적재되기 때문)
- CPU 입장에서 다음에 실행할 명령어 위치를 찾기가 어려워진다

#### 페이지 테이블
- 위에서 설명한 문제를 해결하기 위한 솔루션
- 물리 주소에 불연속적으로 배치되더라도 CPU 입장의 논리 주소에는 연속적으로 배치되도록 하는 방법
- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
- 프로세스마다 페이지 테이블이 있다
- 페이지 테이블에는 페이지 번호와 프레임 번호가 짝지어져 있다
- CPU는 그냥 페이지 테이블를 순차적으로 실행만하면 된다.

- 내부 단편화라는 문제가 생길 수 있다

## 내부 단편화
- 하나의 페이지 크기보다 적게 적재되었을때 생긴다

## 페이지 테이블 베이스 레지스터 (PTBR)
- 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다

## TLB
- 페이지 페이블이 메모리에 있으면 비효율적이다(메모리 접근이 많아지기 때문)
- 이를 해결하기 위해 CPU 곁에 페이지 테이블의 캐시 메모리인 TLB가 생겼다
- 페이지 테이블의 자주 참조하는 테이블의 일부를 가져와 저장한다

## 페이징에서의 주소 변환
- 특정 주소에 접근하고자 한다면 다음과 같은 정보가 필요하다
  1. 어떤 페이지/프레임에 접근하고 싶은지
  2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 페이징 시스템에서의 논리 주소는 페이지 번호와 변위로 이루어져 있다
- <페이지번호, 변위>로 이루어진 논리 주소는 페이지 테이블을 통해 <프레임 번호, 변위>로 변환된다

## 페이지 테이블 엔트리
- 페이지 테이블의 각각의 행: 페이지 테이블 엔트리(PTE)
 - 현재까지 설명한 PTE: 페이지 번호, 프레임 번호
 - 이외에 
  - 유효 비트: 현재 해당 페이지에 접근 가능한지 여부 (0,1로 이루어져 있다)
   - 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴트(page fault)라는 인터럽트가 발생한다
    1. CPU는 기존의 작업 내역을 백업한다
    2. 페이지 폴트 처리 루틴을 실행한다
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다
    4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 할 수 있게 된다
  - 보호 비트 (0,1로 이루어져 있다)
   - 페이지 보호 기능을 위해 존재하는 비트
  - 참조 비트 (0,1로 이루어져 있다)
   - CPU가 이 페이지에 접근한 적이 있는지 여부
  - 수정 비트 (0,1로 이루어져 있다)
   - CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부

## 요구 페이징
- 요구되는, 필요한 페이지만 적재하는 기법
- 요구 페이징이 안정적으로 작동하기 위해서는 페이지 교체와 프레임 할당 문제를 해결해야 한다
1. CPU가 특정 페이지에 접근하는 명령어를 실행한다
2. 해당페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) PCU는 페이지가 적재된 프레임에 접근한다
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생한다
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다
5. 다시 1번을 수행한다

### 페이지 교체 알고리즘
- 페이징 기법을 사용하면 언제가는 메모리가 가득차게된다
- 당장 필요한 페이지를 적재하려면 현재 적재된 페이지를 보조기억장치로 내보내야 한다
- 어떤 페이지를 내보낼지 결정하는 방법(알고리즘)이 페이지 교체 알고리즘 이다
- 페이지 폴트가 적은 알고리즘이 놓은 알고리즘이다

#### FIFO 페이지 교체 알고리즘
- 가장 단순한 방식
- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
- 프로그램 실행 내내 사용될 페이지를 교체 할수있기 때문에 성능면에서 않좋을 수 있다

#### 2차기회 페이지 교체 알고리즘
- FIFO 페이지 교체 알고리즘의 보안책
- 참조 비트 1: CPU가 한번 참조한 적이 있는 페이지
- 참조 비트 0: CPU가 참조한 적이 없는 페이지
- 참조 비트가 1이면 0으로 초기화하고 적재시간을 현재시간으로 재설정한다

#### 최적 페이지 교체 알고리즘
- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지
- 앞으로 사용빈도가 가장 낮은 페이지를 교체하는 알고리즘
- 실제 구현이 어렵다
- 앞으로 오랫동안 사용되지 않을 페이지를 예측하기 어렵기 때문

#### LRU(Least-Recently-Used) 페이지 알고리즘
- 최적 페이지 교체 알고리즘: 가장 오래 사용되지 않을 페이지 교체
- LRU 페이지 교체 알고리즘: 가장 오래 사용되지 않은 페이지 교체
- 최적 페이지 교체 알고리즘와 비슷하지만 구현 가능하다

**이외에도 많지만 여기까지만 알아보자**

## 페이지 폴트가 자주 발생하는 이유
- 메모리 용량이 낮아서
- 나쁜 알고리즘을 사용해서

## 스래싱
- 프로세스가 실행되는 시간 보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제
- 동시 실행되는 프로세스의 수를 늘린다고 CPU이요률이 높아지는 것이 아니다

### 스래싱이 발생하는 이유
- 각 프로세스가 필요로하는 최소한의 프레임수가 보장되지 않았기 때문
- 운영체제들은 각 프로세스가 필요로 하는 최소한의 프레임 수를 파아갛고 프로세스들에게 적절한 프레임을 할당해 주어야한다

## 스래싱과 프레임 할당

### 균등 할당 (정적 할당 방식)
- 가장 단순한 할당 방식
- 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
- 프로세스마다 필요한 프레임의 크기가 다르기 때문에 좋은 방법은 아니다

### 비례 할당 (정적 할당 방식)
- 프로세스의 크기를 고려한다
- 프로세스 크기에 비례하여 프레임 할당
- 프로세스가 필요로하는 프레임수는 실행해봐야 알기 때문에 좋지만은 않다

### 작업 집합 모델 (동적 할당 방식)
- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문인데 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임 할당하면 된다
- 프로세스가 일정 기간동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교페를 방지한다
- 작업 집합이란 실행 중인 프로세스가 일정시간 종안 참조한 페이지의 집합이다

### 페이지 폴트 빈조 (동적 할당 방식)
- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 페이지 폴틍ㄹ에 상한선과 하한선을 정하고, 그내부 범위 안에서만 프레임을 할당하는 방식





















